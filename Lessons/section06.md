## Streaming

- OTT 서비스들은 영화나 드라마처럼 아주 큰 용량의 동영상을 굉장히 빠른 속도로 시청할 수 있도록 만들어 주기 때문에 오늘날 굉장히 많은 사람들에게 사랑을 받고 있다.이 모든 것들을 가능케 하는 것이 바로 스트리밍이라는 기술이다.
- 스트리밍이라는 기술은 서버에서 클라이언트로 어떠한 데이터를 넘겨줘야 될 때 보내줘야하는 데이터의 크기가 너무나도 크거나 또는 서버 측에서 데이터를 준비하는데 걸리는 시간이 꽤나 오래 걸리게 되어서 데이터를 빠르게 전송해주기 어려울 것 같을 때, 전송할 데이터를 여러 개의 조각으로 잘게 쪼갠 다음 쪼개진 작은 용량의 데이터들을 마치 강물에 하나씩 흘려보내듯이 하나하나씩 클라이언트에게 전송하하는 기술을 바로 스트리밍이라고 한다.

  <img width='700px' src='https://github.com/user-attachments/assets/d5137f40-682e-4101-a9df-f6fe700a533e'>
  <img width='700px' src='https://github.com/user-attachments/assets/ad4f743e-777a-4be3-a404-ecebe56d75d0'>

  > 스트림(stream): 개천, 하천

- 다시 말해서 스트리밍이란 어떠한 강물이나 개천을 통해서 물자를 보내듯 잘게 쪼개진 데이터들을 연속적으로 보내주는 기술을 의미한다.
- 스트리밍 기술을 이용하면 데이터가 다 불러와 지지 않은 상태에서도 일단 지금까지 전달받은 데이터에 접근할 수 있기 때문에 결과적으로 사용자에게 긴 로딩 없이 굉장히 좋은 사용자 경험을 제공할 수 있다.

  <img width='700px' src='https://github.com/user-attachments/assets/e7a82daa-e941-4978-afa9-06c94d530795'>
  <img width='700px' src='https://github.com/user-attachments/assets/a232d3b0-d972-44d5-bccd-27cca59e4f7b'>
  <img width='700px' src='https://github.com/user-attachments/assets/3585d074-ba43-4d1d-9bd7-c93eda98dcc9'>

  > HTML 페이지 스트리밍 동작 방식

- Next.js는 이러한 스트리밍이라는 기술의 이점을 동영상 뿐만 아니라 일반적인 웹 서비스에서도 동일하게 누릴 수 있게끔 `HTML 페이지를 스트리밍`하는 기능을 자체적으로 제공하고 있다. 이를 통해서 사용자가 특정 페이지에 접속했을 때 일단 빠르게 렌더링이 오래 걸리지 않는 단순한 컴포넌트들부터 먼저 화면에 보여주고, 데이터 패칭 등의 이유로 렌더링이 오래 걸릴 것으로 예상되는 컴포넌들은 일단 로딩바 같은 대체 UI를 화면에 보여주고 있다가 서버 측에서 컴포넌트의 렌더링이 완료가 되면 그때 뒤는게 해당 컴포넌트들만 따로 전달해서 콘텐츠를 보여주는 방식으로 페이지를 제공할 수 있게 된다.
- 스트리밍을 이용하게 되면 페이지 내부에 렌더링 하는데 아무리 오래 걸리는 컴포넌트가 포함되어 있다고 하더라도 사용자들에게는 일단 뭐라도 빠르게 렌더링할 수 있는 컴포넌트들이라도 보여줄 수 있기 때문에 높은 응답성으로 긍적적인 사용자 경험이 제공하게 된다.
- 서치 페이지를 예로 들면 백엔드 서버로부터 비동기적으로 검색 결과 데이터를 불러오는 페이지 컴포넌트는 브라우저로부터 서치 페이지를 요청 받았을 때, `Streaming`을 적용하지 않는다면 포함된 4개의 컴포넌트들 모두 한 번씩 다 렌더링을 마친 이후에 브라우저에게 페이지를 응답하게 될 것이다. 만약 페이지 컴포넌트에서 수행하는 비동기 작업 데이터를 불러오는 작업이 오래 걸리게 될 경우에는 페이지의 응답 자체가 전체적으로 다 느려지게 되는 문제점이 존재했다.
- 그러나 `Streaming`을 적용하게 되면 비동기적으로 데이터를 불러오고 있는 페이지 컴포넌트의 렌더링 결과는 제외하고 나머지 루트 레이아웃, 서치바 레이아웃, 서치바 컴포넌트 같은 즉시 렌더링할 수 있는 컴포넌트의 결과만 브라우저에게 응답해서 일단 빠르게 화면을 보여주고, 비동기적으로 데이터를 불러오고 있는 페이지 컴포넌트 부분은 로딩바 같은 대체 UI를 보여주고 있다가 뒤늦게 페이지 컴포넌트의 렌더링이 완료되면 그제서야 후속으로 페이지 컴포넌트의 내용을 화면에 렌더링하게 되는 방식으로 동작하게 된다.

  <img width='700px' src='(https://github.com/user-attachments/assets/1dc899d6-5887-41a3-912e-a873a18dc263'>
  <img width='700px' src='https://github.com/user-attachments/assets/be68573d-de79-4bd3-9a7e-21a81f154ce6'>

  > 서치 페이지의 컴포넌트 구조

- 스트리밍이란 쉽게 말해 특정 페이지를 렌더링할 때 비동기 작업이 없는 빠르게 렌더링 될 수 있는 컴포넌트들부터 즉시 브라우저에 렌더링한 뒤 비동기 작업을 포함하고 있는 비교적 렌더링 시간이 오래 걸리는 컴포넌트의 렌더링 결과를 뒤늦게 페이지에 보내주게 되는 동작 방식을 `Streaming`이라고 부른다.
- 이런 Next.js의 `Streaming`은 Dynamic Page에 자주 활용이 된다. Dynamic Page들은 Next.js 서버에서 빌드타임에 생성이 되지 않기 때문에 `Full Route Cache`에는 저장이 되지 않는다. (Static Page만 저장됨) 그렇기 때문에 서치 페이지 같은 다이나믹 페이지들은 브라우저 접속 요청이 들어왔을 때 마다 Next 서버가 페이지의 모든 컴포넌트들을 다 실행해서 페이지를 매번 새롭게 렌더링 해줘야 되기 때문에 이 과정에서 특정 컴포넌트 내부에서 발생하는 서치 API 같은 데이터 페칭이 너무 오래 걸려 버리게 될 경우에 너무 오래 걸려 버리게 될 경우에는 전체 페이지의 응답이 느려지게 되어서 결국에 좋지 않은 사용자 경험을 제공하게 된다.
- 바로 이런 상황에 Next.js의 스트리밍이 필요하게 된다.

  <img width='700px' src='https://github.com/user-attachments/assets/28c0853d-6412-4687-a934-4baac580fcf3'>
  <img width='700px' src='https://github.com/user-attachments/assets/e9cbaed7-4f6e-46e7-b957-44790e89c69a'>
  <img width='700px' src='https://github.com/user-attachments/assets/c3759e38-631d-41b2-afdb-998b295006dc'>
  <img width='700px' src='https://github.com/user-attachments/assets/6844367f-c96e-4a7d-b906-1fbda7e479d2'>

  > 좋지 않은 사용자 경험을 제공하는 Dynamic 페이지의 단점을 해결하는 Streaming

- 페이지 접속 요청이 들어왔을 때 빠르게 오래 걸리지 않는 컴포넌트들만 빠르게 렌더링해서 곧바로 브라우저에 응답해 줌으로써 사용자에게 빈 화면 대신에 일단 레이아웃처럼 빠르게 렌더링할 수 있는 부분들이라도 보여주고, 오래 걸리는 부분들은 로딩바 같은 대체 UI를 보여주고 있다가 Next.js 서버 측에서 데이터 페칭이 완료가 되어서 오래 걸리는 컴포넌트들까지 렌더링이 완료가 되었다면 그때는 후속으로 렌더링된 데이터를 보내줌으로써 실제 데이터를 채워 넣어서 사용자가 로딩 화면을 조금이라도 덜 지루하게 느낄 수 있도록 좋은 사용자 경험을 제공할 수 있게 된다.
- 스트리밍은 마치 비유해보자면 식당에서 어떠한 음식점에 방문을 했을 때 메인 메뉴를 기다리는 동안에 밑반찬이나 물부터 빠르게 점원분이 가져다 주는 것과 유사하다고 생각하면 된다. 밑반찬이 빠르게 나오게 되면 메인 메뉴가 조금 오래 걸리게 되더라도 밑반찬을 먹으면서 기다리면 되기 때문에 꽤나 인내심이 생기게 된다.
- Next.js의 `Streaming`도 오래 걸리는 Dynamic Page 유형의 서버 컴포넌트 렌더링을 사용자가 조금 더 좋은 환경에서 인내심을 가지고 기다릴 수 있도록 빠르게 렌더링이 가능한 컴포넌트들을 밑반찬 처럼 내보재주는 것이라고 이해해볼 수 있다.

### 페이지 스트리밍 적용하기

- 특정 페이지 컴포넌트를 `Streaming` 하도록 설정하려면 해당 페이지 컴포넌트와 동일한 경로에 새로운 파일로 `loading.tsx` 라는 새로운 파일을 하나 만들어 주면 된다. `loading.tsx` 컴포넌트에는 대체 UI 역할을 할 로딩바 같은 역할을 할 요소를 리턴해주면 이제 같은 경로의 `page.tsx` 페이지 컴포넌트는 스트리밍 되도록 자동 설정이 되며, 로딩되는 동안에는 대체 UI로써 `loading.tsx` 파일에 작성한 로딩 컴포넌트가 화면에 대신 렌더링된다.
- 그런데 백엔드 서버와 Next App이 지금 너무 빠르다. 왜냐하면 PC에서 둘다 함께 동작하고 있기 때문에 네트워크 요청을 주고 받는 속도가 굉장히 빠른 상태이다. 데이터를 굉장히 빠르게 불러오기 때문에 로딩 UI를 볼 시간이 없다. 그래서 먼저 페이지 컴포넌트 내부에 강제로 데이터를 불러오는 과정을 지연시키기 위해서 딜레이를 발생시키는 함수를 하나 만들어준다.

  ```typescript
  // /src/util/delay.ts
  export async function delay(ms: number) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve('');
      }, ms);
    });
  }
  // /src/app/(with-searchbar)/search/page.tsx
  ...
  await delay(1500); // 1.5초
  ...
  ```

  <img width='500px' src='https://github.com/user-attachments/assets/04c0f2bb-1a6a-4f95-a1c7-1529f4d95269'>

  > 스크리밍 설정되어 대체 UI가 나오는 보여짐

- 스트리밍을 페이지 컴포넌트에 적용하려면 프로젝트 내 같은 경로에 `loading.tsx`라는 파일을 추가로 생성해줌으로써 같은 경로의 페이지 컴포넌트를 스트리밍 되도록 설정을 해주면, 혹여나 딜레이가 발생함으로써 페이지 컴포넌트를 렌더링하는 데에 굉장히 오랜 시간이 소요가 된다고 하더라도 전체 페이지의 렌더링 자체를 지연시키지는 않기 때문에 페이지 컴포넌트가 아닌 그 외의 비동기 작업이 없는 레이아웃과 같은 컴포넌트들은 화면에 지체 없이 바로 나타나게 될 것이다. 이런 매커니즘을 통해 훨씬 더 좋은 사용자 경험을 제공할 수 있다.

### loading.tsx 파일의 주의할 점 (1)

- `loading.tsx` 파일은 동일한 경로에 있는 페이지 컴포넌트만 스트리밍 되도록 설정하는 것이 아니라 마치 레이아웃 파일처럼 **하위 경로 모든 비동기 페이지 컴포넌트들이 다 스트리밍이 되도록 설정**이 된다. 그렇기 때문에 만약 프로젝트의 서치 폴더 아래 새로운 경로 `/search/setting/page.tsx`가 있다면 setting 페이지 역시 상위 경로에 있는 `loading.tsx` 파일 때문에 자동으로 스트리밍 되도록 설정이 된다. 또한 로딩 중에 대체 UI 또한 로딩 컴포넌트로 동일하게 설정이 된다.
  ```tsx
  import { delay } from '@util/delay';
  export default async function Page() {
    await delay(2000);
    return <div>setting page</div>;
  }
  ```

### loading.tsx 파일의 주의할 점 (2)

- `loading.tsx`파일이 스트리밍하도록 설정하는 페이지 컴포넌트는 모든 페이지 컴포넌트가 아닌, `async` 키워드가 붙어서 비동기로 작동하도록 설정된 페이지 컴포넌트에만 스트리밍을 제공한다.
- 왜냐하면 비동기 컴포넌트가 아니라면 데이터를 불러오지 않고 있다는 뜻이기 때문에 그런 컴포넌트들은 고정된 UI를 렌더링하기 위해 사용된다. 다시말해 `async` 키워드가 붙지 않는 비동기 컴포넌트가 아닌 컴포넌트는 `loading.tsx`가 존재한다고 하더라도 스트리밍 되지 않는다.
- 실험을 하며 만들어둔 setting 페이지 컴포넌트에서 딜레이를 제거하고, `async` 키워드도 붙어있지 않은 동기적인 컴포넌트로 만들어주면 스트리밍이 적용되지 않고 바로 setting 페이지 컴포넌트가 렌더링 됨을 확인할 수 있다.

### loading.tsx 파일의 주의할 점 (3)

- `loading.tsx`라는 파일은 무조건 페이지 컴포넌트에만 스트리밍을 적용할 수 있다.
- 그렇기 때문에 레이아웃이나 또는 서치 페이지에 들어가는 `components`폴더의 book-item이나 searchbar 같은 일반적인 컴포넌트들에는 `loading.tsx`파일로는 스트리밍을 설정할 수 없다.
- 만약 페이지 컴포넌트가 아닌 별도의 컴포넌트들에도 스트리밍을 적용하고 싶다면, loading.tsx 파일을 이용하면 안되고 대신에 React의 Suspense 라는 컴포넌트를 별도로 활용해주어야 한다.

### loading.tsx 파일의 주의할 점 (4)

- loading.tsx 파일로 설정된 스트리밍은 브라우저에서 쿼리스트링이 변경될 때에는 트리거링 되지 않는다.
- 인덱스 페이지에서 서치 페이지로 경로 자체가 바뀌면 `loading.tsx` 파일의 스트리밍이 정상 동작하지만, 대신에 경로상에서 쿼리스트링망 변경하면 스트리밍이 적용되지 않는다.
- 이렇게 되면 별로 사용자 경험이 좋지 않다. 이런 경우에도 스트리밍이 똑같이 동작하도록 만들고 싶다면 이번에도 역시 리액트 Suspense 컴포넌트를 이용해 주어야 한다.

## 컴포넌트 스트리밍 적용하기 : 서치 페이지

- 페이지 컴포넌트 단위로 스트리밍을 적용하는 것은 `BookItem` 또는 `Searchbar` 와 같이 일반적인 컴포넌트들에는 스트리밍을 개별적으로 설정해 줄 수 없었다.
- 이제 일반적인 컴포넌트들에도 자유롭게 스트리밍을 설정할 수 있는 리액트의 `Suspense`라는 컴포넌트를 이용해본다.
- `Suspense`는 `미완성 또는 미결`이라는 뜻을 가지고 있다. `Suspense` 컴포넌트로 감싸준 컴포넌트를 스트리밍하도록 설정해서 미완성 상태, 즉 로딩 상태로 남겨놓게 된다. 그리고 로딩 상태를 표시하는 대체 UI는 `Suspense` 컴포넌트의 `fallback`이라는 Props로 넘겨주면 된다.
- 참고로 `fallback`에 다른 컴포넌트를 전달해줘도 동일하게 동작한다.
- `fallback`이라는 뜻은 `대체재 또는 보완책`이라는 뜻을 가지고 있기 때문에 대체 UI로써 `fallback` Props로 전달되는 컴포넌트가 대신 로딩 상태의 렌더링이 된다.

```typescript
export default async function Page({
  searchParams,
}: {
  searchParams: Promise<{ q: string }>;
}) {
  const { q } = await searchParams;
  return (
    <Suspense fallback={<div>Loading ...</div>}>
      <SearchResult q={q || ''} />
    </Suspense>
  );
}
```

- `Suspense`를 이용하는 방식 또한 `loading.tsx` 파일을 이용하는 방식과 동일하게 브라우저에서 쿼리스트링만 딱 변경되었을 경우에는 로딩 상태가 다시 표시되지 않는 동일한 문제가 존재한다. `loading.tsx`파일에서는 이런 문제를 딱히 해결할 방법이 없었지만 `Suspense`를 이용하고 있을 때에는 이 문제를 생각보다 쉽게 해결할 수 있다.
- 해결방법은 `Suspense` 컴포넌트에 `key` Props를 넘겨주어 이 키 값이 변화할 때마다 다시 로딩 상태로 돌아가도록 설정해주면 된다. 서치 페이지에서는 검색어인 쿼리스트링 `q` 값이 달라질 때마다 로딩을 다시 하도록 만들어주면 된다.
  - `Suspense` 컴포넌트는 최초로 한번 내부 컴포넌트의 로딩이 완료된 이후에는, 내부 컨텐츠가 변경된다 하더라도 기본적으로는 새롭게 다시 로딩 상태로 돌아가지 않는다.
  - 그렇기 때문에 한번 로딩이 마쳐지면 다시는 로딩 상태를 표시할 수 없게 된다. 이럴 때에는 아예 이 `Suspense` 컴포넌트의 `key` Props 값을 바꿔버려서 쿼리스트링이 바뀔때마다 컴포넌트 자체를 리액트에게 `Suspense` 컴포넌트 자체를 새로운 컴포넌트로 인식하도록 하여 아예 새롭게 렌더링 하도록 설정해준다.
  - 리액트에서는 `key` 값이 바뀌면 컴포넌트가 `완전히 다른 컴포넌트가 생겼다`라고 인식하게 되기 때문에 컴포넌트를 완전히 새롭게 그리게 된다.
  - `key` Props 값을 활용해서 마치 트릭처럼 로딩 상태를 다시 표시하게 할 수 있다.

```typescript
export default async function Page({
  searchParams,
}: {
  searchParams: Promise<{ q: string }>;
}) {
  const { q } = await searchParams;
  return (
    <Suspense key={q || ''} fallback={<div>Loading ...</div>}>
      <SearchResult q={q || ''} />
    </Suspense>
  );
}
```

- `Suspense` 컴포넌트의 매력은 하나의 페이지 내에 하나의 컴포넌트만 스트리밍 하도록 설정하는 것이 아니라, 그것보다는 하나의 페이지 내에서 여러가지 비동기 컴포넌트들을 동시다발적으로 스트리밍할 때 비로소 그 진가를 드러낸다.

## 컴포넌트 스트리밍 적용하기 : 인덱스 페이지

- 인덱스 페이지에 `Suspense`를 적용하기 위해서는 우선 `Static Page`인 인덱스 페이지를 `Dynamic Page`로 만들어줘야 한다.
- `Static는Page`는 어차피 빌드 타임에 모든 비동기 작업을 다 끝내놓기 때문에 스트리밍을 적용해봤자 아무런 의미가 없다. 왜냐하면 빌드 타임에 얼마나 오래 걸리든지 모든 컴포넌트가 다 렌더링이 끝나기 때문이다.
- 인덱스 페이지를 빠르게 `Dynamic Page`로 설정하기 위해 저번에 배웠던 `Route Segment Option`인 `dynamic`을 활용한다.
  ```typescript
  // Route Segment Option: dynamic - 강제로 다이나믹 페이지로 설정
  export const dynamic = 'force=dynamic';
  ```
- `Suspense` 컴포넌트를 활용하면 병렬로 하나의 페이지 내에 여러 개의 컴포넌트들을 완료되는 순서대로 화면에 각각 렌더링할 수 있다는 아주 훌륭한 장점이 있다는 것을 기억하도록 하자.
- `Suspense`의 이러한 장점 때문에 `loading.tsx` 파일을 이용하는 방식보다 대부분은 `Suspense` 컴포넌트를 이용하는 방식이 조금 더 선호되고 더 많은 곳에서 범용적으로 활용할 수 있다.

## 스켈레톤 UI 적용하기

- 로딩되는 동안 실제 컨텐츠 대신에 보여지게 될 스켈레톤 UI를 설정해본다.
- 스켈레톤(Skeleton) UI란 뼈대 역할을 하는 UI라고 이해하면 된다. 페이지에 일부 컨텐츠가 로딩이 되는 동안 실제 컨텐츠 대신에 컨텐츠와 비슷하게 생긴 박스 형태의 실루엣 정도를 미리 보여주는 것을 `Skeleton UI`라고 표현한다.
- 이런 스켈레톤 UI를 사용하면 사용자로 하여금 로딩 시간부터 대략 어떻게 생긴 컨텐츠가 로딩이 끝났을 때 나의 눈앞에 나타나게 될 것인지 예상할 수 있도록 만들어 주기 때문에 훨씬 더 좋은 사용자 경험을 제공할 수 있다.

  <img width='700px' src='https://github.com/user-attachments/assets/6141f522-e1ad-441d-8703-07436bc3fc76'>

  > Skeleton UI

- `Suspense`를 통해서 보여지는 대체 UI에서 텍스트만 썰렁하게 나오기 때문에 별로 프로젝트의 완성도가 높아보이진 않기 때문에 조금 아쉽다.
- 인덱스 페이지에서 도서 아이템을 대체하는 스켈레톤 컴포넌트를 만들어서 훨씬 더 완성도 있는 로딩 화면을 설정해 보도록 한다.
- 스켈레톤 컴포넌트의 내부 구성 UI는 기존에 정상적으로 렌더링되는 컴포넌의 대략적인 디자인을 그대로 가져가면 된다.
- 여러개의 `Skeleton UI`를 리스트로 렌더링을 해야 될 때, 중복해서 쓰지 않고 리스트의 역할을 하는 컴포넌트를 하나 만들어서 Props로 몇개의 `Skeleton` 리스트가 필요한지 전달만 하면 그 만큼의 스켈레톤 컴포넌트들을 리스트로 렌더링해주는 컴포넌트를 만들어 사용하는 것이 깔끔하다.

  ```tsx
  import BookItemSkeleton from './book-item-skeleton';

  export default function BookListSkeleton({ count }: { count: number }) {
    return new Array(count)
      .fill(0)
      .map((_, idx) => <BookItemSkeleton key={`book-item-skeleton-${idx}`} />);
  }
  ```

- `Skeleton UI`는 사실 필수적인 기능까지는 아니다. 그럼에도 해당 내용이 강의의 별도 챕터로 포함된 이유는 Skeleton UI가 잘 설정되어 있을 떄 사용자의 입자에서는 조금 더 완성도 있다는 느낌을 받거나 또는 로딩을 조금 더 수월하게 기다릴 수 있기 때문에 꼭 알아두면 좋겠다고 판단해서이다.
- 그래서 프로젝트를 직접 진행할 때에는 이런 `Skeleton UI`를 잘 활용하면 좋을 것 같다.
- 또 한 가지 Tip을 드리면 `React Loading Skeleton`이라는 자동으로 스켈레톤 UI를 만들어주는 라이브러리도 존재한다. 스켈레톤 UI를 직접 퍼블리싱 하기 귀찮다면 이런 라이브러리를 설치해서 애니메이션까지 존재하는 스켈레톤을 한번 사용해 보길 추천한다.

  <img width='700px' src='https://github.com/user-attachments/assets/009d8596-bea9-4b59-96db-ddcafa771520'>

  > npm: React Loading Skeleton

## 에러 핸들링

- Next.js App에서 발생하는 다양한 에러를 처리하는 핸들링 방법에 대해서 알아본다.
- 실험을 위해 백엔드 API 서버 실행을 중단하고 `RecoBooks` 컴포넌트에 try-catch 문을 적용해주면 인덱스 페이지에서 에러가 발생하지 않음을 볼 수 있다. 백엔드 API 서버가 실행이 종료 되었음에도 `AllBooks` 컴포넌트는 `cache: "force-cache"` 옵션이 적용되어 있기 때문에 무조건 캐싱된 데이터만 사용하도록 설정이 되어 있다. 그래서 최초로 한 번 요청한 이후에는 다시는 요청하게 되지 않기 때문에 결국 백엔드 서버에게는 아무런 요청도 날라지 않게 되어서 오류가 발생하지 않게 된 것이다.
- 기본적으로 Next.js App에서도 JavaScript의 try-catch 블럭을 이용해서 간단하게 에러를 처리해줄 수 있다. 하지만 이런 방식은 데이터 패칭 같이 오류가 발생할 가능성이 있는 모든 코드 블럭마다 일일이 이런 try-catch문을 넣어줘야 되기 때문에 귀찮기도 하고, 예상하지 못하는 부분에서도 얼마든지 오류가 발생할 수 있기 떄문에 신경써줘야 되는 점도 그 만큼 많아지게 된다.
- 그래서 Next.js는 특정 경로에서 발생한 모든 오류들을 다 한꺼번에 처리할 수 있는 아주 편리한 에러 핸들링 기능을 하나 가지고 있다. 이 방법은 try-catch 구문을 사용하는 대신에 에러를 처리할 수 있는 파일을 하나 만들어 준다. 마치 스트리밍을 설정할 때 `loading.tsx` 파일을 만들어뒀던 것처럼 설정해주고 싶은 페이지 컴포넌트와 같은 경로에 새로운 파일로 `error.tsx`라는 에러 핸들링을 담당할 파일을 하나 만들어주면 된다.
- 특히 `error.tsx` 파일은 `"use client"` 디렉티브(지시자)를 추가해서 이 에러 컴포넌트를 클라이언트 컴포넌트로 설정까지 해주어야 한다.

  ```typescript
  'use client';
  export default function Error() {
    return (
      <div>
        <h3>오류가 발생했습니다.</h3>
      </div>
    );
  }
  ```

- 이렇게 해주면 `error.tsx` 파일과 같은 경로에 있거나 하위에 있는 서치 폴더의 페이지에서 오류가 발생하게 되면 에러 컴포넌트가 페이지 컴포넌트 대신에 화면에 출력이 된다. 마치 `Suspense` 컴포넌트의 `fallback` Props로 넘겨지는 대체 UI를 설정하는 것과 비슷하다.

  <img width='700px' src='https://github.com/user-attachments/assets/0051865d-be8e-4a50-a4a4-07d66b570ebd'>

  > 에러가 발생하면 화면에 대신 렌더링되는 error 컴포넌트

- 참고로 에러 컴포넌트를 `"use client"` 디렉티브 (지시자)를 통해서 클라이언트 컴포넌트로 꼭 설정을 해줘야 되는 이유는 기본적으로 오류라는 건 서버이든지 클라이언트든지 막란하고 어떤 환경에서든 다 발생할 수 있기 때문에 모두 함께 다 대응할 수 있도록 클라이언트 컴포넌트로 설정을 해줘야 한다.
- 왜냐하면 클라이언트 컴포넌트는 서버 측에서도 실행이 되고 클라이언트 측에서도 동일하게 실행되기 때문이다. 그래서 서버나 클라이언트 어떤 환경에서 오류가 발생하던 다 에러 컴포넌트가 대응할 수 있도록 클라이언트 컴포넌트로 만들어 주는 것이다.
- 에러 컴포넌트를 만들어주면 특정 경로에 페이지 컴포넌트에서 발생하는 에러들은 효과적으로 핸들링 할 수 있게 된다. 그런데 만약 현재 발생한 에러의 원인이나 또는 에러의 메시지를 에러 컴포넌트를 통해 출력하도록 만들고 싶다면 에러 컴포넌트의 props로 전달되는 `error`라는 값을 이용하기만 하면 된다. Next.js에서는 이렇게 에러라는 이름의 props로 현재 발생한 오류의 정보를 에러 컴포넌트에게 자동으로 보내주게 된다.
- 참고로 에러의 타입은 JavaScript에 존재하는 기본적인 `Error` 타입이다.
- Next는 에러가 발생했을 때 에러 컴포넌트에 JavaScript Error 타입의 에러 객체를 props로 에러 컴포넌트에게 전달해준다.
- 또 `Error` 객체에는 `message`라는 속성이 있어, 에러가 발생했을 때 `message`만 출력하면 깔끔하게 에러 내용만 출력할 수 있다.
- 에러 컴포넌트에게는 `reset`이라는 하나의 props가 더 제공이 된다. 이 `reset`은 이름 그대로 에러가 발생한 페이지를 복구하기 위해서 다시 한번 컴포넌트들을 렌더링 시켜보는 기능을 가지고 있는 함수이다. `reset` 함수는 매개변수로 아무것도 받지도 반환값으로 아무것도 반환하지 않는 `void` 타입이다.

  ```typescript
  // error.tsx
  'use client';

  import { useEffect } from 'react';

  export default function Error({
    error,
    reset,
  }: {
    error: Error;
    reset: () => void;
  }) {
    useEffect(() => {
      console.log(error.message);
    }, [error]);

    return (
      <div>
        <h3>오류가 발생했습니다.</h3>
        <button onClick={() => reset()}>다시 시도</button>
      </div>
    );
  }
  ```

- 실험을 위해 중단한 서버를 다시 실행하고, 다시 시도 버튼을 눌러도 계속 에러가 발생하고 있는 상황을 볼 수 있을 것이다. 그러한 이유는 에러 컴포넌트에 전달되는 `reset`이라는 메서드는 사실 그냥 브라우저 (클라이언트) 측에서만 현재 서버로부터 전달받은 데이터를 이용해서 화면을 다시 한번 렌더링 해보기만 하는 메서드이기 떄문이다.

  <img width='700px' src='https://github.com/user-attachments/assets/39f8dd29-ade4-45f9-985f-78404ab8c7fe'>

  > Error의 reset 함수를 실행하는 다시 하기를 실행해도 다시 실행되지 않는 서버 컴포넌트

- 구체적으로 설명하면, 서버 측에서 실행되는 서버 컴포넌트를 다시 실행하지는 않는 것이다. 그래서 인덱스 페이지에서 다시 시도 버튼을 눌러도 인덱스 페이지 컴포넌트의 RecoBooks 컴포넌트나 AllBooks 컴포넌트를 다시 실행하는 건 아니기 때문에 데이터 페칭을 다시 수행하지는 않는다. 그렇기 때문에 결국 에러 컴포넌트의 `reset` 메서드만 가지고는 현재 발생한 오류를 복구할 수는 없다.
- 대신에 클라이언트 컴포넌트 내부에서 발생한 오류만 복구할 수 있을 것이다.
- 이러한 경우 문제를 해결하기 위해서 가장 쉬운 방법은 브라우저 API를 사용해서 강제로 새로고침하는 것이다. `window.location.reload()`를 사용하면 페이지에 초기 접속하는 것과 동일하기 동작하기 때문에 서버 측에서 (Dynamic 페이지로 설정되어 있으므로) 서버 컴포넌트들을 다시 실행하게 될 것이고, 오류가 해결된다.

  ```typescript
  // error.tsx
  ...
  return (
    <div>
      <h3>오류가 발생했습니다.</h3>
      <button onClick={() => window.location.reload()}>다시 시도</button>
    </div>
  );
  ```

- 하지만 이렇게 하면 브라우저에 보관해뒀던 `state`나 또는 클라이언트 컴포넌트들의 각종 데이터들이 싹 날아가버리기도 하고 게다가 에러가 발생하지 않은 레이아웃이나 또 별도의 컴포넌트들까지 완전히 새롭게 다시 다 렌더링이 되어야 하기 때문에 우아한 방법이라고 하기에는 조금 어려운 감이 있다.
- 오류가 자주 발생하는 것도 아니긴 해서 이렇게 `window.location.reload()`를 해도 큰 지장은 없긴 하겠지만 조금 더 우아하게 오류가 발생한 부분만 새롭게 렌더링을 하고 싶다면, 우선 컴포넌트 내부에 router 객체를 `next/navigation` 패키지로 불러와서 다시 시도 버튼을 눌러 `onClick` 이벤트가 실행되었을 때 브라우저 API를 호출해서 새로고침하는 것이 아니라 대신에 router 객체의 `refresh` 메서드를 호출해서 Next.js 서버에게 서버 컴포넌트만 새롭게 렌더링 해달라고 요청한 다음에 props로 전달받은 `reset` 함수를 그 뒤에 호출해서 `router.refresh` 메서드를 호출해서 전달받은 새롭게 렌더링된 서버 컴포넌트의 데이터를 화면에 다시 렌더링 하도록 코들르 작성해주면 된다.

```typescript
return (
  <div>
    <h3>오류가 발생했습니다.</h3>
    <button
      onClick={() => {
        router.refresh(); // 현재 페이지에 필요한 서버 컴포넌트들을 다시 불러옴
        reset(); // 에러 상태를 초기화, 컴포넌트들을 다시 렌더링
      }}
    >
      다시 시도
    </button>
  </div>
);
```

- router 객체의 refresh 메서드는 우리가 일반적으로 생각하는 refresh랑 조금 다르다. `router.refresh` 메서드는 현재 페이지에 필요한 서버 컴포넌트들을 다시 불러오는 역할을 한다. 즉, 현재 페이지에 필요한 서버 컴포넌트들을 Next.js 서버 측에 다시 한번 실행해줄 것을 요청하는 메서드인 것이다.
- 인덱스 페이지의 경우 RecoBooks나 AllBooks와 같은 인덱스 페이지에 존재하는 서버 컴포넌트들을 서버 측에서 다시 한번 실행해서 그 결과 `RSC Payload`를 브라우저에게 다시 돌려달라고 요청하는 그런 메서드이다. 그리고 그렇게 다시 받은 서버 컴포넌트의 결과 값을 화면에 다시 렌더링 시켜주는 메서드이다.
- `refresh` 메서드가 호출되면 서버 측에서 RecoBooks나 AllBooks 컴포넌트를 다시 렌더링을 진행하기 때문에 이런 fetch 메서드도 다시 한번 호출이 되어 새로운 `RSC Payload`를 결과값으로 브라우저에게 전달이 된다. 그리고 전달된 결과값을 화면에 다시 한번 업데이트까지 시켜주는 기능을 가지고 있다.
- 쉽게 말하면 `router.refresh` 메서드는 페이지에서 서버 컴포넌트만 빠르게 업데이트 시키는 메서드라고 생각하면 된다.
- 그러면 `router.refresh` 메서드만 쓰면 되지, Error 컴포넌트 페이지의 props로 받은 `reset` 메서드는 왜 다시 호출하는지 의문이 생길 수 있다. 그 이유는 `reset` 함수의 역할이 클라이언트 컴포너트를 다시 렌더링하는 기능과 더불어 에러 상태를 초기화하는 기능을 가지고 있기 때문이다.
- 에러 상태는 클라이언트 컴포넌트이기 때문에 `router.refresh` 메서드를 호출해서 서버 컴포넌트들을 다시 불러와서 렌더링 한다고 해도 클라이언트 컴포넌트인 렌더링된 에러 컴포넌트가 사라지진 않는다. 다시 말해, 에러 상태가 초기화 되지 않는다는 의미이다.
- 그렇기 때문에 `router.refresh` 메서드 이후에 에러 상태를 초기화 하는 `reset` 함수를 추가로 호출해주어야 서버 컴포넌트의 결과 값도 다시 계산하고 에러 상태도 다시 초기화하는 동작이 연쇄적으로 일어나게 되어 페이지를 복구 시킬 수 있는 것이다.
- 서버를 종료했다가 에러를 발생시킨 다음 서버를 실행하여 브라우저에서 다시 시도 버튼을 눌러보아도 오류가 복구되지 않은 걸 확인할 수 있다. 네트워크 탭을 통해서 보더라도 응답 값이 서버 컴포넌트 데이터인 `RSC Payload`로 정상적으로 불러오고 있는데 화면은 다시 렌더링 되지 않고 있다. 이번엔 문제가 무엇을 일까.
- 그 이유는 `router.refresh` 메서드가 사실은 비동기로 동작하는 메서드이기 때문이다. 그래서 refresh 메서드가 끝나기도 전에 그냥 `reset` 메서드가 실행이 돼버려서 새로운 컴포넌트의 결과도 없이 그냥 화면을 새롭게 다시 그리기 때문에 오류가 복구되지 않는 것이다.
- 이 문제를 해결하려면 `router.refresh` 메서드가 끝난 다음에 `reset` 메서드가 호출되게 하면 되므로, 간단하게 생각하면 `async/await`을서사용해서 `router.refresh` 메서드를 실행해주면 될 것 같지만 이 방법으로는 해결되지 않는다. `router.refresh` 메서드는 타입이 `Promise`가 아닌 반환값이 없는 `void` 타입이기 때문이다. 즉, refresh 메서드는 비동기 객체를 반환하지 않는다는 것이다. 그렇기 떄문에 await으로 동기적으로 동작하도록 만들 수가 없다.
- 이런 경우에는 React 18버전부터 추가된 새로운 메서드인 `startTransition` 메서드를 활용하면 된다. 이 `startTransition` 메서드의 역할은 하나의 Callback 함수를 인수로 전달 받아서 Callback 함수 안에 들어있는 UI를 변경시키는 작업들을 모두 일괄적으로 처리를 해준다. `startTransition` 메서드의 인수로 전달되는 Callback 함수에 `router.refresh` 메서드와 `reset` 함수를 동시에 넣어주게 되면, `router.refresh` 메서드가 수행하는 서버 컴포넌트들을 다시 불러와서 화면을 렌더링시키는 작업과 `reset` 메서드가 수행하는 에러 상태를 초기화하고 클라이언트 컴포넌트들을 다시 렌더링하는 작업이 모두 일괄적으로 동시에 처리가 되기 때문에 결과적으로 에러 상태를 복구할 수 있다.
- 즉, `startTransition`의 Callback 함수에 들어가는 `router.refresh` 메서드와 `reset` 함수가 한 몸처럼 움직이게 된다.
- 그래서 서버 컴포넌트의 결과까지 불러오고 나서 에러 상태를 초기화하게 된다.
- 이런 식으로 `error.tsx` 파일을 통해서 페이지 컴포넌트 내부에서 발생한 에러들을 정상적으로 복구하거나 오류 메시지를 표시하는 기능을 만들 수 있다.

  ```typescript
  'use client';

  import { useRouter } from 'next/navigation';
  import { startTransition, useEffect } from 'react';

  export default function Error({
    error,
    reset,
  }: {
    error: Error;
    reset: () => void;
  }) {
    const router = useRouter();
    useEffect(() => {
      console.log(error.message);
    }, [error]);

    return (
      <div>
        <h3>오류가 발생했습니다.</h3>
        <button
          onClick={() =>
            startTransition(() => {
              // React18에 추가된 메서드로 콜백 함수에 포함된 작업을 한 몸처럼 수행
              router.refresh(); // 현재 페이지에 필요한 서버 컴포넌트들을 다시 불러옴
              reset(); // 에러 상태를 초기화, 컴포넌트들을 다시 렌더링
            })
          }
        >
          다시 시도
        </button>
      </div>
    );
  }
  ```

### error.tsx 파일의 위치에 따른 처리 결과

- `error.tsx` 파일은 동일한 경로에 있는 인덱스 페이지 뿐만 아니라 하위 경로의 모든 페이지에 다 동일하게 적용이 되기 떄문에 `error.tsx` 파일 하위 경로에 있는 서치 페이지에서 에러가 발생하더라도 똑같이 에러 컴포넌트가 화면에 렌더링이 된다.
- 만약 서치 페이지만의 별도의 에러 컴포넌트가 필요하다라고 하면, 서치 페이지 컴포넌트의 경로에 별도의 `error.tsx` 파일을 만들어주면 된다.
- 따로 만들어준 `error.tsx` 파일은 상위에 있는 `error.tsx` 파일을 덮어 씌워 대체하게 된다.

  <img width='500px' src='https://github.com/user-attachments/assets/0ecf66b3-1213-46ef-ac2b-05144ea8d420'>

  > 별도의 에러 페이지 컴포넌트로 서치 페이지의 에러 핸들링

- 북 페이지의 경우 book 폴더 내에 `error.tsx` 파일이 존재하지 않고, 상위 경로에도 존재하지 않기 때문에 에러 핸들링이 이루어지지 않은 상황이다. 북 페이지의 에러까지 포함하여 핸들링 해주기 위해서는 `(with-searchbar)` 폴더 안에 들어 있었던 `error.tsx` 파일을 `app` 바로 아래 배치 해주면 된다.
- 그러면 모든 페이지에 기본적으로 에러가 발생 시, 에러 컴포넌트가 다 나타나게 된다.
- 한 가지 주의해야 할 점은, `app` 폴더 밑에 `error.tsx` 파일을 바로 만들어주게 되면 에러가 발생했을 때 최상위의 `app` 폴더 바로 아래 있는 `layout.txs`까지만 렌더링이 된다.
- 인덱스 페이지에서 발생한 오류 화면을 보면 서치바 레이아웃이 렌더링 되지 않은 걸 볼 수 있다.
- `error.tsx` 파일은 자기와 같은 경로에 있는 레이아웃까지만 렌더링을 시켜주기 때문이다.

  <img width='500px' src='https://github.com/user-attachments/assets/f6b5ec79-94ae-4ddb-a384-61d8bda22c73'>

  > 서치바 레이아웃은 생략되고 최상위 레이아웃까지만 렌더링된 `app/error.tsx` 파일 배치 결과

- 이런 상황이 싫다면, 어쩔 수 없이 파일을 `(with-searchbar)` 폴더 아래로 다시 옮겨서 에러가 발생하더라도 서치바 레이아웃까지 렌더링 되도록 설정을 해준다.
- 그리고 북 페이지까지 에러를 핸들링 해주기 위해, `error.tsx` 파일을 복사해서 `book` 폴더 밑에다가 하나 더 붙여넣어주면 된다. 그러면 서치바 레이아웃을 생략하지 않으면서도 모든 페이지에 에러 핸들링이 설정된다.
